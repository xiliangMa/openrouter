# 架构设计

本文档详细说明MassRouter SaaS平台的系统架构设计。

## 整体架构

### 架构图
```
┌─────────────────────────────────────────────────────────────┐
│                     客户端 (浏览器/API)                      │
└─────────────────┬──────────────────┬────────────────────────┘
                  │                  │
        ┌─────────▼──────────┐ ┌────▼──────────┐
        │    管理后台前端     │ │  门户网站前端   │
        │    (admin:3000)    │ │  (portal:3001) │
        └─────────┬──────────┘ └────┬───────────┘
                  │                  │
                  └──────┬───────────┘
                         │
                ┌────────▼──────────┐
                │    后端API服务     │
                │    (backend:8080) │
                └─────────┬──────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
┌───────▼──────┐ ┌───────▼──────┐ ┌───────▼──────┐
│  PostgreSQL  │ │    Redis     │ │  外部API     │
│   (主数据库)  │ │   (缓存/队列)  │ │ (OpenAI等)   │
└──────────────┘ └──────────────┘ └──────────────┘
```

### 组件说明
1. **前端应用**: 两个独立的Next.js应用
   - 管理后台 (`admin.openrouter.ai`): 内部管理界面
   - 门户网站 (`openrouter.ai`): 用户访问界面
2. **后端API**: Go编写的统一API服务，提供RESTful接口
3. **数据库**: PostgreSQL存储持久化数据
4. **缓存**: Redis用于会话、缓存和队列
5. **外部服务**: 大模型供应商API集成

## 技术架构

### 后端架构

#### 分层架构
```
┌─────────────────────────────────────┐
│           HTTP接口层 (API)           │
├─────────────────────────────────────┤
│         控制器层 (Controller)        │
├─────────────────────────────────────┤
│         业务逻辑层 (Service)         │
├─────────────────────────────────────┤
│         数据访问层 (Repository)      │
├─────────────────────────────────────┤
│          数据模型层 (Model)          │
└─────────────────────────────────────┘
```

#### 核心模块
1. **认证授权模块**
   - JWT令牌管理
   - OAuth2提供商集成
   - 权限控制系统 (RBAC)

2. **用户管理模块**
   - 用户注册/登录
   - 个人资料管理
   - API密钥管理

3. **模型管理模块**
   - 供应商配置管理
   - 模型信息管理
   - 价格策略管理

4. **计费系统模块**
   - 余额管理
   - 支付集成
   - 消费记录

5. **统计排名模块**
   - 实时数据统计
   - 排行榜计算
   - 数据分析

### 数据库设计

#### 核心实体关系
```
用户 (User) ──┬── API密钥 (ApiKey)
              ├── 充值记录 (Payment)
              ├── 消费记录 (Billing)
              └── 会话 (Session)

模型供应商 (Provider) ──┬── 模型 (Model)
                        └── API配置 (ApiConfig)

模型 (Model) ──┬── 价格配置 (Pricing)
               └── 统计记录 (Statistic)
```

#### 表设计原则
1. **规范化设计**: 满足3NF规范
2. **索引优化**: 高频查询字段建立索引
3. **分区策略**: 大表按时间分区
4. **软删除**: 使用`deleted_at`标记删除

### 缓存策略

#### 缓存层级
1. **L1缓存**: 内存缓存 (Go sync.Map)
2. **L2缓存**: Redis集群
3. **CDN缓存**: 静态资源缓存

#### 缓存内容
- 用户会话信息
- 模型配置信息
- 热门排行榜数据
- API响应缓存

### 消息队列

#### 使用场景
1. **异步任务**: 邮件发送、数据统计
2. **事件处理**: 用户注册、支付成功
3. **日志处理**: 操作日志记录

#### 技术选型
- **主要**: Redis Streams
- **备选**: RabbitMQ / Apache Kafka

## 安全架构

### 认证授权
1. **多因素认证**: 密码 + 二次验证
2. **OAuth2集成**: 支持主流第三方登录
3. **API密钥管理**: 细粒度权限控制
4. **会话管理**: JWT + Refresh Token

### 数据安全
1. **传输加密**: TLS 1.3+
2. **数据加密**: 敏感字段加密存储
3. **访问控制**: 行级安全策略
4. **审计日志**: 完整操作记录

### 网络安全
1. **防火墙**: 端口限制，IP白名单
2. **DDoS防护**: 速率限制，CDN保护
3. **WAF**: Web应用防火墙

## 性能架构

### 扩展性设计
1. **水平扩展**: 无状态服务，支持多实例
2. **读写分离**: 数据库主从架构
3. **缓存分层**: 多级缓存策略
4. **异步处理**: 非核心业务异步化

### 性能优化
1. **数据库优化**: 查询优化，索引策略
2. **缓存策略**: 热点数据缓存
3. **连接池**: 数据库连接复用
4. **CDN加速**: 静态资源分发

### 监控指标
1. **应用层**: QPS, 响应时间, 错误率
2. **系统层**: CPU, 内存, 磁盘, 网络
3. **业务层**: 用户数, 请求量, 收入

## 部署架构

### 环境划分
1. **开发环境**: 本地开发，功能测试
2. **测试环境**: 集成测试，性能测试
3. **预发环境**: 生产配置，最终验证
4. **生产环境**: 线上服务，用户访问

### 部署策略
1. **蓝绿部署**: 零停机更新
2. **金丝雀发布**: 渐进式发布
3. **回滚机制**: 快速故障恢复

### 基础设施
1. **容器化**: Docker统一运行环境
2. **编排**: Kubernetes容器编排
3. **服务网格**: Istio流量管理
4. **监控**: Prometheus + Grafana

## 集成架构

### 第三方服务集成
1. **支付服务**: 支付宝、微信支付、Stripe
2. **OAuth2提供商**: GitHub、Google、微信等
3. **大模型API**: OpenAI、Anthropic、Google AI等
4. **邮件服务**: SMTP或邮件服务商API
5. **短信服务**: 用户验证码发送

### 集成模式
1. **适配器模式**: 统一接口，多提供商适配
2. **熔断机制**: 服务降级，故障隔离
3. **重试策略**: 指数退避，失败处理

## 数据流架构

### 用户请求流程
```
1. 用户请求 → CDN → 负载均衡器 → 前端应用
2. 前端API调用 → API网关 → 后端服务
3. 后端处理 → 数据库/缓存 → 外部API
4. 响应返回 → 前端渲染 → 用户
```

### 数据同步流程
```
1. 外部API数据 → 消息队列 → 数据处理器
2. 数据处理器 → 数据库更新 → 缓存刷新
3. 缓存更新 → 前端数据更新
```

### 计费流程
```
1. API调用 → 计费服务 → 余额检查
2. 余额充足 → 扣费记录 → 响应返回
3. 余额不足 → 充值提示 → 支付流程
4. 支付成功 → 余额更新 → 继续服务
```

## 容灾架构

### 高可用设计
1. **多可用区部署**: 跨机房容灾
2. **自动故障转移**: 服务自动切换
3. **数据备份**: 定期备份，异地容灾
4. **监控告警**: 实时监控，快速响应

### 故障恢复
1. **RTO (恢复时间目标)**: < 30分钟
2. **RPO (恢复点目标)**: < 5分钟数据丢失
3. **应急预案**: 详细故障处理流程

## 演进路线

### 阶段1: MVP版本
- 基础用户管理
- 核心模型接入
- 简单计费系统

### 阶段2: 增强版本
- 完整OAuth2支持
- 高级统计功能
- 多支付方式集成

### 阶段3: 企业版本
- 多租户支持
- 高级安全特性
- 自定义工作流

### 阶段4: 平台版本
- 插件系统
- 开放API平台
- 生态合作伙伴

## 技术决策记录

### 关键决策
1. **选择Go语言**: 高性能，并发能力强，适合API服务
2. **选择Next.js**: 服务端渲染，SEO友好，开发体验好
3. **选择PostgreSQL**: 功能丰富，ACID支持，扩展性好
4. **选择Redis**: 高性能，数据结构丰富，社区活跃

### 权衡考虑
1. **单体 vs 微服务**: 初期选择单体，后期按需拆分
2. **SQL vs NoSQL**: 核心业务用SQL，缓存用NoSQL
3. **自建 vs 云服务**: 核心自建，非核心用云服务

## 附录

### 性能目标
- API响应时间: P95 < 200ms
- 系统可用性: 99.9%
- 并发支持: 1000+ QPS
- 数据一致性: 最终一致性

### 容量规划
- 用户规模: 10万+
- 日请求量: 100万+
- 数据存储: 1TB+
- 缓存容量: 100GB+
